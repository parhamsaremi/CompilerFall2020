%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{}

\پاسخ{}
\\
روش 
value by call :
در این حالت از پارامترها یک کپی ایجاد شده و سپس 
به تابع پاس داده می‌شوند.
در مثال داده شده جای 
a
و
b
هر دو 1 قرار خواهد گرفت و پس از تعریف متغیر جدید
i با مقدار اولیه ی 0 به عنوان متغیر محلی ،
مقادیر a
و
b
جابجا میشوند.
پس درون این تابع مقادیر 1 و1 و 0 و خود آرایه چاپ شده و سپس
در تابع اصلی هم مقدار i
و آرایه
چاپ می‌شود.
لازم به ذکر است که
مقدا{${$}ر i
گلوبال است.
\\
خروجی:
\begin{latin}
1 , 1 , 0 , \big\{0 , 1, 2, 3, 4\big\}
\\
1 , \big\{0 , 1, 2, 3, 4\big\}
\end{latin}

\\
روش 
refrence by call
:
در
این حالت یک اشاره‌گر به مقادیر اصلی ایجاد شده و این مقادیر به
تابع داده خواهند شد.
در این مثال هنگام اجرای تابع فراخوانی شده، یک اشاره‌گر به هرکدام از
i
و عضو دوم
آرایه
خواهیم داشت
که هر دو نیز برابر 1 خواهند بود.
سپس در تابع مان با مقادیر آدرس این متغیرها سر و کار داریم و
محتوای این دو آدرس را با هم جابجا می‌کنیم.
مقدار
i
نیز
در ابتدا
و تا آخر 0 است.
این مقدار در تابع اصلی گلوبال بوده و 1 چاپ خواهد شد.
مقادیر درون آدرس‌ها نیز جابجا شده ولی چون هر دو برابرند، تغییری ایجاد نمی‌شود.
\\
خروجی:
\begin{latin}
1 , 1 , 0 , \big\{0 , 1, 2, 3, 4\big\}
\\
1 , \big\{0 , 1, 2, 3, 4\big\}
\end{latin}

روش 
name by call
:
در این روش
پارامترها پیش از پاس داده شدن به تابع محاسبه نشده‌اند و مستقیماً
در تابع جایگزین شده‌اند.
 سپس هرگاه در بدنه‌ی تابع ظاهر شده باشند،
محاسبه می‌شوند و لذا اگر پارامتری صرفاً به تابع پاس داده شده باشد اما استفاده نشده باشد، هیچ‌گاه محاسبه نخواهد شد.
نکته‌ی قابل ملاحظه در این روش این است که
هر بار هر پارامتر از ابتدا حساب خواهد شد.
در مثال داده شده ابتدا 1 و 1 به تابع داده می‌شوند. سپس
در تابع مقادیر a
و
b
برابر 0
شده و
جابجا نیز می‌شوند.
i
نیز
دوباره از نو تعریف شده و 0 میگردد.
به علت آن که همه چیز در این روش از نو حساب می‌شود،
مقادیر چاپ شده‌ی متغیرها 0 خواهند بود.
\\
خروجی:
\begin{latin}
0 , 0 , 0 , \big\{0 , 1, 2, 3, 4\big\}
\\
0 , \big\{0 , 1, 2, 3, 4\big\}
\end{latin}



روش 
value-result by call
:
در این حالت انعکاس تغییر در پارامترهای تابع را در مکان صدا زدن تابع هم می‌بینیم.
در هنگام صدا زدن تابع،
ابتدا 1  و 1 به تابع داده خواهند شد.
سپس
یک متغیر جدید
i درون
تابع با مقدار اولیه 0 خواهیم داشت که در آخر نیز 0 باقی خواهد ماند.
مقادیر
a
و
b
نیز جابجا خواهند شد
و در نهایت هر دو برابر 1 خواهند ماند.
از آنجا که در این روش، تغییرات در تابع صدا زده شده ، در تابع اصلی هم 
انعکاس می‌یابد،
مقادیر داده شده به تابع در 
main
هم جابجا میشوند اما چون برابرند این تغییر مشاهده نشده است.
\\
خروجی:
\begin{latin}
1 , 1 , 0 , \big\{0 , 1, 2, 3, 4\big\}
\\
1 , \big\{0 , 1, 2, 3, 4\big\}
\end{latin}