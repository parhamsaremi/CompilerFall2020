%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{}

\پاسخ{}

روش 
name by call
:
در این روش
پارامترها پیش از پاس داده شدن به تابع محاسبه نشده‌اند و مستقیماً
در تابع جایگزین شده‌اند.
 سپس هرگاه در بدنه‌ی تابع ظاهر شده باشند،
محاسبه می‌شوند و لذا اگر پارامتری صرفاً به تابع پاس داده شده باشد اما استفاده نشده باشد، هیچ‌گاه محاسبه نخواهد شد.
نکته‌ی قابل ملاحظه در این روش این است که
هر بار هر پارامتر از ابتدا حساب خواهد شد.
لذا سرعت این نوع از پاس دادن پارامتر به مراتب کمتر از حالت بعدی،
یعنی روش
need by call
است.
برای مثال اگر تابع ما به صورت زیر باشد:
\begin{latin}
add(a, b)
\small\{
\\
return a + b;
\\
\small\}
\end{latin}
و اینگونه تابع را صدا کنیم:
\\
\begin{latin}
print( add(5 - 2 , 7  * 1) );
\\
\end{latin}
تمام این محاسبات انجام خواهند شد:
\begin{latin}
\\
a = 5 - 2 = 3
\\
b = 7 * 1 = 7
\\
a + b = 3 + 7 = 10
\end{latin}
و در نهایت تابع عدد 10 
برگردانده  و
همین مقدار هم چاپ خواهد شد.
\\ \\
روش
need by call
:
این روش مشابه روش قبل 
است با این تفاوت که
حالت
memorized
آن است،
یعنی اگر متغیری پیش‌تر حساب شده باشد،
مقدارش ذخیره می‌شود تا مجدداً حساب نشود
 و لذا این روش بهینه‌تر است.
به علاوه تا هنگامی
که نیاز نشود،
محاسبه‌ای انجام نمی‌دهد.
مزیت این کار این است که اگر اشتباهی مقداری در کد آورده شده باشد که لازم به محاسبه‌ی
آن نباشد،
محاسبه نمی‌شود،
زیرا تنها پارامترهایی که نیاز به مقدار آن‌ها پیدا خواهیم کرد محاسبه خواهند شد.
در واقع این روش
هر پارامتر را یا 1 بار در صورتی که نیاز شود حساب می‌کند و یا اصلاً حساب نمی‌کند.
در واقع در مثال بالا، 
تابع 
\begin{latin}
\math{(5 - 2) + (7 * 1)}
\end{latin}

\\
را برمی‌گرداند
و تنها زمانی که نیاز باشد ،
یعنی هنگامی که میخواهیم این حاصل را در خروجی نمایش دهیم 
آن را محاسبه کرده و 10 را چاپ خواهد کرد.
\\
به عنوان توضیح بیشتر برای بهینه بودن این روش ،
می‌توان کد زیر را مثال زد:
\begin{latin}
firstElement(list)
\small\{
\\
return [list[0]];
\small\}
\\
\end{latin}
که اگر آن را اینگونه فراخوانده باشیم:
\\
\begin{latin}
firstElement([0 ... infinity]);
\end{latin}
\\
مشاهده خواهیم کرد که تابع با رویه‌ی
name by call
نمی‌تواند این کار را انجام دهد و هنگ خواهد کرد زیرا در همان هنگام صدا زدن ،
میخواهد لیستی با تعداد عناصر بی‌نهایت بسازد.
اما در زبان با رویه‌ی
need by call
،
خروجی به راحتی محاسبه شده و لذا تنها عنصر نخست لیست برگردانده خواهد شد.
\\
\\
روش 
result by call
:
در این روش
مقدار اولیه
هنگام خوانده شدن در 
callee
نامعلوم است ولی پیش از برگرداندن مقدار به
caller
مقدار در آن کپی خواهد شد و تعیین می‌شود.
\\
از آنجا که در این روش کپی از هر یک از متغیرها ایجاد می‌شود،
این روش به حافظه‌ی بیشتری نیاز دارد.
در واقع در برخی زبان‌ها، که اکثراً زبان‌های قدیمی هستند،
برای جلوگیری از ابهام‌های حاصل از
aliases
،
به جای روش
refrence by call
از این روش استفاده می‌شود که در آن متغیرهای
مشابه تولید نشوند.
\\
برای مثال اگر تابع  زیر را داشته باشیم:
\begin{latin}
add(a,b)\small\{
\\
a=1;
\\
b=2;
\\
return a+b;
\small\}
\\
\end{latin}
و در تابع main
هم داشته باشیم
:
\begin{latin}
a=10;
\\
b=20;
\\
print( add(a,b) );
\end{latin}
مقدار چاپ شده برابر با 3 خواهد بود و نه 30،
چرا که در این روش مقدار در همان تابع callee
و پیش از برگرداندن به 
caller
تعیین شده و مقدار اولیه هم 
نامعلوم تلقی می‌شود.
\\
برای تولید
TAC
این مثال خواهیم داشت:
پس از آنکه جهت هماهنگ شدن ساختار ابتدا زبان decaf
را برای این کد نوشتیم،
TAC
آن را تولید می‌کنیم.
به این صورت که ابتدا در تابع 
main
،
a
و
b
مقادیر 10 و 20 را به
خود می‌گیرند.
سپس تابع
add
به طور
need by call
صدا زده شده و مقادیر ورودی‌های
آن یعنی هر دوی 
a
و
b
برابر
null
قرار داده شده و در استک قرار می‌گیرند.
سپس درون تابع متغیرهای جدید 
c
و
d
که همان
a
و
b
هستند تولید شده و در نهایت مقادیرجدیدشان 
،
یعنی همان 1 و 2
در
a
و
b
قرار گرفته و سپس از استک
pop 
شده و پس از آزاد شدن فضای اختصاص یافته به آن‌ها،
a
و
b
مربوط به تابع
main
از استک حذف می‌شوند و مقدار جدید یعنی 3
چاپ می‌شود.
در ضمن فرض کرده‌ایم که متغیرها نیز همگی 4 بیتی هستند.

\begin{latin}
TAC
\\
\\
\underline{\hspace{.05in}}add:
\\
BeginFunc 8;
\\
c=1;
\\
d=2;
\\
a=c;
\\
b=d;
\\
EndFunc;

\\
\underline{\hspace{.05in}}main:
\\
BeginFunc 8;
\\
a=10;
\\
b=20;
\\
PushParam a = Null;
\\
PushParam b = Null;
\\
Lcall \underline{\hspace{.05in}}add;
\\
PopParams 8;
\\
EndFunc;
\\
\end{latin}

